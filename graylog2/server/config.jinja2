{#-
Copyright (c) 2013, Bruno Clermont
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Author: Bruno Clermont <patate@fastmail.cn>
Maintainer: Bruno Clermont <patate@fastmail.cn>
-#}
# {{ pillar['message_do_not_modify'] }}
{#-
 If you are running more than one instances of graylog2-server you have to
 select one of these instances as master. The master will perform some
 periodical tasks that non-masters won't perform.
#}
{% set email = salt['pillar.get']('graylog2:smtp', pillar['smtp']) %}
is_master = true

plugin_dir = /usr/local/graylog2-server-{{ version }}/plugin

syslog_listen_port = 1514
syslog_listen_address = 0.0.0.0
syslog_enable_udp = true
syslog_enable_tcp = false
syslog_use_nul_delimiter = false
syslog_store_full_message = true

{# Socket receive buffer size (bytes) for UDP syslog and UDP GELF.#}
udp_recvbuffer_sizes = 1048576

# Embedded elasticsearch
elasticsearch_config_file = /etc/graylog2-elasticsearch.yml
elasticsearch_max_docs_per_index = {{ salt['pillar.get']('graylog2:max_docs', 20000000) }}
elasticsearch_index_prefix = graylog2-{{ grains['id'] }}
{#-
 How many indices do you want to keep? If the number of indices exceeds this
 number, older indices will be dropped.
#}
elasticsearch_max_number_of_indices = {{ salt['pillar.get']('graylog2:max_indices', 20) }}
{#-
 How many ElasticSearch shards and replicas should be used per index? Note that
 this only applies to newly created indices.
#}
elasticsearch_shards = {{ salt['pillar.get']('graylog2:shards', 4) }}
elasticsearch_replicas = {{ salt['pillar.get']('graylog2:replicas', 0) }}
{#-
 Analyzer (tokenizer) to use for message and full_message field. The "standard"
 filter usually is a good idea.
 All supported analyzers are: standard, simple, whitespace, stop, keyword,
 pattern, language, snowball, custom
 ElasticSearch documentation:
  http://www.elasticsearch.org/guide/reference/index-modules/analysis/
 Note that this setting only takes effect on newly created indices.
#}
elasticsearch_analyzer = standard

{#-
 How many minutes of messages do you want to keep in the recent index? This
 index lives in memory only and is used to build the overview and stream pages.
 Raise this value if you want to see more messages in the overview pages. This
 is not affecting for example searches which are always targeting *all* indices.
#}
recent_index_ttl_minutes = {{ salt['pillar.get']('graylog2:recent_index_ttl_minutes', 60) }}

{#-
 Storage type of recent index. Allowed values: niofs, simplefs, mmapfs, memory
 Standard: niofs - Set to memory for best speed but keep in mind that the whole
 recent index has to fit into the memory of your ElasticSearch machines. Set
 recent_index_ttl_minutes to a reasonable amount that will let the messages fit
 into memory.
#}
recent_index_store_type = niofs

{#-
 Always try a reverse DNS lookup instead of parsing hostname from syslog
 message?
#}
force_syslog_rdns = false
{#-
 Set time to NOW if parsing date/time from syslog message failed instead of
 rejecting it?
#}
allow_override_syslog_date = true

{#-
 Batch size for all outputs. This is the maximum (!) number of messages an
 output module will get at once.
 For example, if this is set to 5000 (default), the ElasticSearch Output will
 not index more than 5000 messages at once. After that index operation is
 performed, the next batch will be indexed. If there is only 1 message waiting,
 it will only index that single message. It is important to raise this parameter
 if you send in so many messages that it is not enough to index 5000 messages at
 once. (Only at *really* high message rates)
#}
output_batch_size = 5000

{#-
 The number of parallel running processors.
 Raise this number if your buffers are filling up.
#}
processbuffer_processors = {{ salt['pillar.get']('graylog2:processbuffer_processors', 5) }}
outputbuffer_processors = {{ salt['pillar.get']('graylog2:outputbuffer_processors', 5) }}

{#-
 Wait strategy describing how buffer processors wait on a cursor sequence.
 (default: sleeping)
 Possible types:
  - yielding
     Compromise between performance and CPU usage.
  - sleeping
     Compromise between performance and CPU usage. Latency spikes can occur
     after quiet periods.
  - blocking
     High throughput, low latency, higher CPU usage.
  - busy_spinning
     Avoids syscalls which could introduce latency jitter. Best when threads can
     be bound to specific CPU cores.
#}
processor_wait_strategy = {{ salt['pillar.get']('graylog2:processor_wait_strategy', 'blocking') }}

{#-
 Size of internal ring buffers. Raise this if raising outputbuffer_processors
 does not help anymore.
 For optimum performance your LogMessage objects in the ring buffer should fit
 in your CPU L3 cache.
 Start server with --statistics flag to see buffer utilization.
 Must be a power of 2. (512, 1024, 2048, ...)
#}
ring_size = {{ salt['pillar.get']('graylog2:ring_size', 1024) }}

mongodb_useauth = false
{#mongodb_user = grayloguser
mongodb_password = 123
mongodb_replica_set = localhost:27017,localhost:27018,localhost:27019#}
mongodb_host = 127.0.0.1
mongodb_database = graylog2
mongodb_port = 27017
{#-
 Raise this according to the maximum connections your MongoDB server can handle
 if you encounter MongoDB connection problems.
#}
mongodb_max_connections = 100
{#-
 Number of threads allowed to be blocked by MongoDB connections multiplier.
 Default: 5
 If mongodb_max_connections is 100, and
 mongodb_threads_allowed_to_block_multiplier is 5, then 500 threads can block.
 More than that and an exception will be thrown.
 http://api.mongodb.org/java/current/com/mongodb/MongoOptions.html
  #threadsAllowedToBlockForConnectionMultiplier
#}
mongodb_threads_allowed_to_block_multiplier = 5

use_gelf = true
gelf_listen_address = 0.0.0.0
gelf_listen_port = 12201

{#- Drools Rule File (Use to rewrite incoming log messages)
# See: http://support.torch.sh/help/kb/graylog2-server/
                custom-message-rewritingprocessing
# rules_file = /etc/graylog2.d/rules/graylog2.drl
#}

{% if salt['pillar.get']('graylog2:amqp', False) %}
amqp_enabled = true
amqp_host = {{ pillar['amqp']['host'] }}
amqp_port = {{ pillar['amqp']['port'] }}
amqp_username = {{ pillar['graylog2']['rabbitmq']['user'] }}
amqp_password = {{ pillar['graylog2']['rabbitmq']['password'] }}
amqp_virtualhost = {{ pillar['graylog2']['rabbitmq']['vhost'] }}
{% else %}
amqp_enabled = false
{% endif %}

{#- HTTP input
# http://support.torch.sh/help/kb/graylog2-server/using-the-gelf-http-input
http_enabled = false
http_listen_address = 0.0.0.0
http_listen_port = 12202
#}

{#-
 The following is used only for Alert, when there is too much logs coming in
 for a specific period of time.
 For stream email, the configuration is in the web UI in email output plugin
 section.
 IMPORTANT: graylog2-server need to be restarted after any change in
  mail output plugin settings.
#}
transport_email_enabled = true
{%- if email['encryption']|default('plain') == 'SSL/TLS' %}
transport_email_protocol = smtps
transport_email_use_tls = true
{%- else %}
transport_email_protocol = smtp
transport_email_use_tls = false
{%- endif %}
transport_email_hostname = {{ email['server'] }}
transport_email_port = {{ email['port'] }}
transport_email_use_auth = true
transport_email_auth_username = {{ email['user']|default("null") }}
transport_email_auth_password = {{ email['password']|default("null") }}
transport_email_subject_prefix = [graylog2]
transport_email_from_email = {{ email['from'] }}
transport_email_from_name = Graylog2
transport_email_web_interface_url = http{% if ssl|default(False) %}s:{% endif %}://{{ pillar['graylog2']['hostnames'][0] }}

enable_graphite_output = true
{% if 'graphite_address' in pillar %}
graphite_carbon_host = {{ pillar['graphite_address'] }}
graphite_carbon_tcp_port = 2003
graphite_prefix = {{ grains['id'] }}.logs
{% endif %}

# Filters
# Enable the filter that tries to extract additional fields from k=v values in the log message?
enable_tokenizer_filter = true

{#- Jabber/XMPP transport
transport_jabber_enabled = false
transport_jabber_hostname = jabber.example.com
transport_jabber_port = 5222
transport_jabber_use_sasl_auth = true
transport_jabber_allow_selfsigned_certs = false
transport_jabber_auth_username = your_user
transport_jabber_auth_password = secret
transport_jabber_message_prefix = [graylog2]#}
